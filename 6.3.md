# 6/3 월 공부

## 데이터구조 - Sorting

### 병합정렬(Merge Sort)

*원소 개수가 1 또는 0이 될 때까지 두 부분으로 쪼개고 쪼개서 자른 순서의 역순으로 크기를 비교해 병합

1. 리스트의 중간 지점을 계산
2. 주어진 리스트를 반으로 나눈다
3. 전반부와 후반부를 독립적으로 정렬(재귀호출)
4. 전반부와 후반부를 병합하여 하나의 정렬된 리스트를 만든다

* 수행시간:O(nlogn)

#### 약점

* 내부정렬이 아니다 (내부정렬:주어진 리스트 이외에 추가로 공간을 사용하지 않는 정렬)
* merge 과정에서 배열 A[0..n-1] 만큼의 보조배열 tmp[0..n-1] 생성 및 처리 필요
* 보조배열 tmp[0..n-1]로 저장한 merge 결과를 배열 A[0..n-1]로 되쓰는 과정도 시간자체 요인

### 퀵정렬(Quick Sort)

* 선행작업을 한 다음 재귀적으로 작은 문제를 해결하는 방법
* 기준 원소를 잡아 기준 원소보다 작은 원소와 큰 원소 그룹으로 분할한 다음 각각을 정렬하는 방법

1. 기준원소(맨 마지막 원소)를 선택
2. 기준원소를 중심으로 양쪽으로 분할
3. 왼쪽과 오른쪽 각각을 정렬(재귀호출)

* 수행시간 : O(nlogn)

#### 약점

* 입력이 이미 정렬되어 있거나 거의 정렬되어 있는 경우 -> O(n2)
* 동일한 원소가 많이 존재하는 경우

### 힙정렬(Heap Sort)

1. 리스트 A[0..n-1]이 주어진다.
2. 힙을 만든다:buildHeap()
3. root node를 제거(최대값)
4. 힙을 수선한다:percolateDown()
5. 힙이 빌때까지 3~4 과정을 반복

### 쉘정렬(Shell Sort)

* 각 원소가 있어야 할 자리에서 멀리 떨어져 있을 가능성을 줄이는 작업을 선행하고 삽입정렬을 수행

1. 리스트 A[0..n-1] 가 주어진다
2. 리스트 A를 h0 간격의 부분리스트로 나눈다
3. 각 그룹을 삽입 정렬 한다
4. 더 좁아진 간격의 h1로 만들어지는 부분 리스트를 각각 삽입 정렬한다
5. 간격을 h2,h3...으로 좁혀가면서 삽입 정렬을 반복한다
6. 간격이 1이 되면 리스트 전체를 삽입정렬하고 정렬을 종료한다

[고금 정렬 코드](http://localhost:8889/lab/tree/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B5%AC%EC%A1%B0-Sorting2.ipynb)

